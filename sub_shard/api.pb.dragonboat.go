// This code was autogenerated from protoc-gen-dragonboat, do not edit.
package sub_shard

import (
	"context"
	"fmt"
	"runtime/debug"

	sm "github.com/lni/dragonboat/v3/statemachine"
	"google.golang.org/protobuf/proto"

	"github.com/LilithGames/protoc-gen-dragonboat/runtime"
)

type ISubShardDragonboatServer interface {
	Get(req *GetRequest) (*GetResponse, error)
	Incr(req *IncrRequest) (*IncrResponse, error)
}

type ISubShardDragonboatClient interface {
	Get(ctx context.Context, req *GetRequest, opts ...runtime.DragonboatClientOption) (*GetResponse, error)
	Incr(ctx context.Context, req *IncrRequest, opts ...runtime.DragonboatClientOption) (*IncrResponse, error)
}

func DragonboatSubShardLookup(s ISubShardDragonboatServer, query interface{}) (result interface{}, err error) {
	defer func() {
		if perr := recover(); perr != nil {
			err = fmt.Errorf("panic: %v\nstacktrace from panic: %s", perr, string(debug.Stack()))
		}
	}()
	switch q := query.(type) {
	case *GetRequest:
		resp, err := s.Get(q)
		if err != nil {
			return resp, fmt.Errorf("ISubShardServer.Get(%v) err: %w", q, err)
		}
		return resp, nil
	case *runtime.DragonboatVoid:
		// healthcheck
		return &runtime.DragonboatVoid{}, nil
	default:
		return nil, runtime.NewDragonboatError(runtime.ErrCodeUnknownRequest, fmt.Sprintf("ErrCodeUnknownRequest type: %T", q))
	}
}

func DragonboatSubShardUpdateDispatch(s ISubShardDragonboatServer, msg proto.Message) (result proto.Message, err error) {
	defer func() {
		if perr := recover(); perr != nil {
			err = fmt.Errorf("panic: %v\nstacktrace from panic: %s", perr, string(debug.Stack()))
		}
	}()
	switch m := msg.(type) {
	case *IncrRequest:
		resp, err := s.Incr(m)
		return resp, err
	case *runtime.DragonboatVoid:
		// dummy update increate index
		return &runtime.DragonboatVoid{}, nil
	default:
		return nil, runtime.NewDragonboatError(runtime.ErrCodeUnknownRequest, fmt.Sprintf("ErrCodeUnknownRequest type: %T", m))
	}
}

func DragonboatSubShardUpdate(s ISubShardDragonboatServer, data []byte) (sm.Result, error) {
	msg, err := runtime.ParseDragonboatRequest(data)
	if err != nil {
		return runtime.MakeDragonboatResult(nil, err), nil
	}
	resp, err := DragonboatSubShardUpdateDispatch(s, msg)
	return runtime.MakeDragonboatResult(resp, err), nil
}

func DragonboatSubShardConcurrentUpdate(s ISubShardDragonboatServer, entries []sm.Entry) ([]sm.Entry, error) {
	for i := range entries {
		entry := &entries[i]
		msg, err := runtime.ParseDragonboatRequest(entry.Cmd)
		if err != nil {
			entry.Result = runtime.MakeDragonboatResult(nil, err)
		} else {
			resp, err := DragonboatSubShardUpdateDispatch(s, msg)
			entry.Result = runtime.MakeDragonboatResult(resp, err)
		}
	}
	return entries, nil
}

type SubShardDragonboatClient struct {
	client runtime.IDragonboatClient
}

func NewSubShardDragonboatClient(client runtime.IDragonboatClient) ISubShardDragonboatClient {
	return &SubShardDragonboatClient{client: client}
}
func (it *SubShardDragonboatClient) Get(ctx context.Context, req *GetRequest, opts ...runtime.DragonboatClientOption) (*GetResponse, error) {
	resp, err := it.client.Query(ctx, req, opts...)
	return runtime.ClientResponseConversion[*GetResponse](resp, err)
}
func (it *SubShardDragonboatClient) Incr(ctx context.Context, req *IncrRequest, opts ...runtime.DragonboatClientOption) (*IncrResponse, error) {
	resp, err := it.client.Mutate(ctx, req, opts...)
	return runtime.ClientResponseConversion[*IncrResponse](resp, err)
}
